# Стек - абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO
# # (англ. last in — first out, «последним пришёл — первым вышел»). Чаще всего принцип работы стека сравнивают со
# стопкой тарелок: чтобы взять вторую сверху, нужно снять верхнюю. Или с магазином в огнестрельном оружии(стрельба
# начнётся с патрона, заряженного последним).
#
# Необходимо реализовать класс Stack со следующими методами:
# isEmpty - проверка стека на пустоту. Метод возвращает True или False.
# push - добавляет новый элемент на вершину стека. Метод ничего не возвращает.
# pop - удаляет верхний элемент стека. Стек изменяется. Метод возвращает верхний элемент стека
# peek - возвращает верхний элемент стека, но не удаляет его. Стек не меняется.
# size - возвращает количество элементов в стеке.
# Используя стек из задания 1 необходимо решить задачу на проверку сбалансированности скобок. Сбалансированность
# скобок означает, что каждый открывающий символ имеет соответствующий ему закрывающий, и пары скобок правильно
# вложены друг в друга. Сбалансированными последовательности будут следующие скобки:
# (((([{}]))))
# [([])((([[[]]])))]{()}
# {{[()]}} Несбалансированными последовательности:
# }{}
# {{[(])]}}
# [[{())}]
# Программа ожидает на вход строку со скобками. На выход сообщение "Сбалансированно", если строка корректная
# и "Небалансированно", если строка составлена не верно.


class Stack(list):

    def isEmpty(self):
        """Проверка стека на пустоту. Метод возвращает True или False"""
        if bool(self):
            return False
        else:
            return True

    def push(self, value):
        """Добавляет новый элемент на вершину стека. Метод ничего не возвращает"""
        self.append(value)

    def new_pop(self):
        """Удаляет верхний элемент стека. Стек изменяется. Метод возвращает верхний элемент стека"""
        return self.pop(-1)

    def peek(self):
        """Возвращает верхний элемент стека, но не удаляет его. Стек не меняется"""
        return self[-1]

    def size(self):
        """Возвращает количество элементов в стеке"""
        return len(self)


test1 = '(((([{}]))))'
test2 = '[([])((([[[]]])))]{()}'
test3 = '{{[()]}}'
test4 = '}{}'
test5 = '{{[(])]}}'
test6 = '[[{())}]'


def check(data):
    """Проверяет сбалансированность скобок"""
    data_s = Stack(data)
    ind = True
    if data_s.size() % 2 == 0: # Проверяет, если количество элементов нечётное, последовательность не сбалансирована
        while not data_s.isEmpty():
            # Если последовательность заканчивается на не закрытую скобку последовательность не сбалансирована
            if data_s.peek() == '{' or data_s.peek() == '[' or data_s.peek() == '(':
                ind = False
                break
            # Проверяет последовательность с конца, если есть пара скобок,
            # удаляет последнюю скобку, разворачивает последовательность,
            # удаляет ближайшую к ней парную скобку и разворачивает назад
            if data_s.peek() == ')' and '(' in data_s:
                data_s.new_pop()
                data_s.reverse()
                data_s.remove('(')
                data_s.reverse()
            elif data_s.peek() == ']' and '[' in data_s:
                data_s.new_pop()
                data_s.reverse()
                data_s.remove('[')
                data_s.reverse()
            elif data_s.peek() == '}' and '{' in data_s:
                data_s.new_pop()
                data_s.reverse()
                data_s.remove('{')
                data_s.reverse()
            # Если больше нет парных скобок, а елементы в последовательности остались, она не сбалансирована
            else:
                ind = False
                break
    else:
        ind = False
    # Выводит результат
    if ind:
        print(f'Последовательность {data} сбалансирована')
    else:
        print(f'Последовательность {data} не сбалансирована')


check(test1)
check(test2)
check(test3)
check(test4)
check(test5)
check(test6)